# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/team-strength.ipynb (unless otherwise specified).

__all__ = ['ModelABC', 'Benchmark', 'DCGoals', 'DCxG', 'eps_values', 'MODEL_REGISTRY']

# Cell
import abc
import collections
import datetime as dt

import mezzala
import numpy as np

import wingback.db

# Cell


class ModelABC:
    @abc.abstractmethod
    def fetch_data(self, league_ids, date):
        training_data = ...  # e.g. matches up-to, not including `date`
        return training_data

    @abc.abstractmethod
    def fit(self, data):
        return self

    @abc.abstractmethod
    def predict(self, data):
        predictions = ...
        return predictions

    @abc.abstractmethod
    def to_dict(self):
        return ...

# Cell


class Benchmark(ModelABC):
    """
    A benchmark model that gives the same predictions for every match.

    This prediction is simply an average of the observed scoreline frequency
    within the training data.
    """

    def __init__(self, time_window=360):
        self._time_window = time_window

        self._data = None

    @property
    def time_window(self):
        return dt.timedelta(days=self._time_window)

    def fetch_data(self, league_ids, date):
        training_data = wingback.db.queries.fetch_matches(
            start=date-self.time_window,
            end=date,
            league_ids=league_ids,
            season_ids=[None]
        )

        return list(training_data)

    def fit(self, data):
        counts = collections.Counter((x['home_goals'], x['away_goals']) for x in data)
        self._data = [
            mezzala.ScorelinePrediction(
                home_goals=hg,
                away_goals=ag,
                probability=count/len(data)
            )
            for (hg, ag), count in counts.items()
        ]
        return self

    def predict(self, data):
        # Just make the same prediction for every match
        return [self._data]*len(data)

    def to_dict(self):
        return {
            'time_window': self._time_window
        }

# Internal Cell


def encode_parameter_key(key):
    if isinstance(key, mezzala.OffenceParameterKey):
        return ('Offence', key.label)
    if isinstance(key, mezzala.DefenceParameterKey):
        return ('Defence', key.label)
    if isinstance(key, mezzala.ParameterKey):
        return key.label
    return key

# Cell


class DCGoals(ModelABC):
    def __init__(self, time_window=360, epsilon=-0.0065, params=None):
        self._time_window = time_window
        self._epsilon = epsilon

        # Create the model
        base_adapter = mezzala.KeyAdapter(
            home_goals='home_goals',
            away_goals='away_goals',
            home_team='home_team_id',  # Might be nicer to do a tuple of (ID, name)?
            away_team='away_team_id',
        )
        self._model = mezzala.DixonColes(
            adapter=mezzala.LumpedAdapter(
                base_adapter,
                home_team=('Other team', 5),
                away_team=('Other team', 5),
            ),
            blocks=[
                mezzala.blocks.BaseRate(),
                mezzala.blocks.TeamStrength(),
                mezzala.blocks.HomeAdvantage(),
                mezzala.blocks.ConstantBlock(
                    mezzala.OffenceParameterKey('Other team'),
                    mezzala.DefenceParameterKey('Other team')
                ),
            ],
            weight=mezzala.weights.ExponentialWeight(
                epsilon=epsilon,
                key=lambda x: x['days_ago']
            ),
            params=params
        )

    @property
    def time_window(self):
        return dt.timedelta(days=self._time_window)

    def fetch_data(self, league_ids, date):
        training_data = wingback.db.queries.fetch_matches(
            start=date-self.time_window,
            end=date,
            league_ids=league_ids,
            season_ids=[None]
        )

        return list(training_data)

    def fit(self, data):
        self._model.adapter.fit(data)
        self._model.fit(data)
        return self

    def predict(self, data):
        predictions = self._model.predict(data)
        return predictions

    def to_dict(self):
        return {
            'time_window': self._time_window,
            'epsilon': self._epsilon,
            'params': [
                (encode_parameter_key(k), v if not np.isnan(v) else None)
                for k, v in self._model.params.items()
            ]
        }

# Cell


class DCxG(ModelABC):
    def __init__(self, min_probability=0.01, time_window=360, epsilon=-0.0065):
        self._time_window = time_window
        self._epsilon = epsilon
        self.min_probability = min_probability

        base_adapter = mezzala.KeyAdapter(
            home_goals='home_goals',
            away_goals='away_goals',
            home_team='home_team_id',
            away_team='away_team_id',
        )
        self._model = mezzala.DixonColes(
            adapter=mezzala.LumpedAdapter(
                base_adapter,
                # On average, each match has about 6 resimulated scorelines
                # so we pick a cutoff of 30 (6*5) data points for lumping teams
                home_team=('Other team', 6*5),
                away_team=('Other team', 6*5),
            ),
            blocks=[
                mezzala.blocks.BaseRate(),
                mezzala.blocks.TeamStrength(),
                mezzala.blocks.HomeAdvantage(),
                mezzala.blocks.ConstantBlock(
                    mezzala.OffenceParameterKey('Other team'),
                    mezzala.DefenceParameterKey('Other team')
                ),
            ],
            weight=mezzala.weights.KeyWeight(
                lambda x: x['probability']*np.exp(self._epsilon*x['days_ago'])
            )
        )

    @property
    def time_window(self):
        return dt.timedelta(days=self._time_window)

    def fetch_data(self, league_ids, date):
        training_matches = list(wingback.db.queries.fetch_matches(
            start=date-self.time_window,
            end=date,
            league_ids=league_ids,
            season_ids=[None]
        ))
        training_resimulations = list(wingback.db.queries.fetch_resimulations(
            match_ids=[m['id'] for m in training_matches],
            min_probability=self.min_probability
        ))

        test_data = wingback.db.queries.fetch_matches(
            start=date,
            end=date+dt.timedelta(days=1),
            league_ids=league_ids,
            season_ids=[None]
        )

        # Merge matches and training data
        training_data = []
        for match in training_matches:
            training_data += [
                {**match, **t}
                for t in training_resimulations
                if t['match_id'] == match['id']
            ]

        return list(training_data)

    def fit(self, data):
        self._model.adapter.fit(data)
        self._model.fit(data)
        return self

    def predict(self, data):
        predictions = self._model.predict(data)
        return predictions

    def to_dict(self):
        return {
            'time_window': self._time_window,
            'min_probability': self.min_probability,
            'epsilon': self._epsilon,
            'params': [
                (encode_parameter_key(k), v if not np.isnan(v) else None)
                for k, v in self._model.params.items()
            ]
        }

# Cell
eps_values = np.log(np.linspace(0.01, 0.95, 10))/365
eps_values

# Cell

MODEL_REGISTRY = {}


MODEL_REGISTRY['benchmark'] = Benchmark(time_window=730)

for eps in eps_values:
    MODEL_REGISTRY[f'dixon-coles{eps:0.6f}'] = DCGoals(time_window=730, epsilon=eps)
    MODEL_REGISTRY[f'dixon-coles-xg{eps:0.6f}'] = DCxG(time_window=730, epsilon=eps, min_probability=0.01)